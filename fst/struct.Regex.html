<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Regex` struct in crate `fst`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Regex">

    <title>fst::Regex - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>fst</a></p><script>window.sidebarCurrent = {name: 'Regex', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>fst</a>::<wbr><a class='struct' href=''>Regex</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-2950' class='srclink' href='../src/fst/regex/mod.rs.html#91-94' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Regex {
    // some fields omitted
}</pre><div class='docblock'><p>A regular expression for searching FSTs with Unicode support.</p>

<p>Regular expressions are compiled down to a deterministic finite automaton
that can efficiently search any finite state transducer. Notably, most
regular expressions only need to explore a small portion of a finite state
transducer without loading all of it into memory.</p>

<h1 id='syntax' class='section-header'><a href='#syntax'>Syntax</a></h1>
<p><code>Regex</code> supports fully featured regular expressions. Namely, it supports
all of the same constructs as the standard <code>regex</code> crate except for the
following things:</p>

<ol>
<li>Lazy quantifiers, since a regular expression automaton only reports
whether a key matches at all, and not its location. Namely, lazy
quantifiers such as <code>+?</code> only modify the location of a match, but never
change a non-match into a match or a match into a non-match.</li>
<li>Word boundaries (i.e., <code>\b</code>). Because such things are hard to do in
a deterministic finite automaton, but not impossible. As such, these
may be allowed some day.</li>
<li>Other zero width assertions like <code>^</code> and <code>$</code>. These are easier to
support than word boundaries, but are still tricky and usually aren&#39;t
as useful when searching dictionaries.</li>
</ol>

<p>Otherwise, the <a href="http://doc.rust-lang.org/regex/regex/index.html#syntax">full syntax of the <code>regex</code>
crate</a>
is supported. This includes all Unicode support and relevant flags.
(The <code>U</code> and <code>m</code> flags are no-ops because of (1) and (3) above,
respectively.)</p>

<h1 id='matching-semantics' class='section-header'><a href='#matching-semantics'>Matching semantics</a></h1>
<p>A regular expression matches a key in a finite state transducer if and only
if it matches from the start of a key all the way to end. Stated
differently, every regular expression <code>(re)</code> is matched as if it were
<code>^(re)$</code>. This means that if you want to do a substring match, then you
must use <code>.*substring.*</code>.</p>

<p><strong>Caution</strong>: Starting a regular expression with <code>.*</code> means that it could
potentially match <em>any</em> key in a finite state transducer. This implies that
all keys could be visited, which could be slow. It is possible that this
crate will grow facilities for detecting regular expressions that will
scan a large portion of a transducer and optionally disallow them.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<p>This example shows how to run a regular expression on a <code>Set</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>fst</span>::{<span class='ident'>IntoStreamer</span>, <span class='ident'>Streamer</span>, <span class='ident'>Regex</span>, <span class='ident'>Set</span>};

<span class='kw'>let</span> <span class='ident'>set</span> <span class='op'>=</span> <span class='ident'>Set</span>::<span class='ident'>from_iter</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;foo&quot;</span>, <span class='string'>&quot;foo1&quot;</span>, <span class='string'>&quot;foo2&quot;</span>, <span class='string'>&quot;foo3&quot;</span>, <span class='string'>&quot;foobar&quot;</span>])
              .<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='ident'>re</span> <span class='op'>=</span> <span class='ident'>Regex</span>::<span class='ident'>new</span>(<span class='string'>&quot;f[a-z]+3?&quot;</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>stream</span> <span class='op'>=</span> <span class='ident'>set</span>.<span class='ident'>search</span>(<span class='kw-2'>&amp;</span><span class='ident'>re</span>).<span class='ident'>into_stream</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>keys</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
<span class='kw'>while</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>key</span>) <span class='op'>=</span> <span class='ident'>stream</span>.<span class='ident'>next</span>() {
    <span class='ident'>keys</span>.<span class='ident'>push</span>(<span class='ident'>key</span>.<span class='ident'>to_vec</span>());
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>keys</span>, <span class='macro'>vec</span><span class='macro'>!</span>[
    <span class='string'>&quot;foo&quot;</span>.<span class='ident'>as_bytes</span>(), <span class='string'>&quot;foo3&quot;</span>.<span class='ident'>as_bytes</span>(), <span class='string'>&quot;foobar&quot;</span>.<span class='ident'>as_bytes</span>(),
]);</pre>

<h1 id='warning-experimental' class='section-header'><a href='#warning-experimental'>Warning: experimental</a></h1>
<p>While executing a regular expression against a finite state transducer will
be very fast, <em>construction</em> of a regular expression automaton may not be.
Namely, this implementation is a proof of concept. In particular, one of
its major deficiencies is that it can use enormous amounts of memory.
Note though, that the construction phase will return an error if the
underlying automata grows too big (tens of MB).</p>

<p>This is important functionality, so one should count on this implementation
being vastly improved in the future.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class='struct' href='../fst/struct.Regex.html' title='fst::Regex'>Regex</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-3002' class='srclink' href='../src/fst/regex/mod.rs.html#104-124' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>(re: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='type' href='../fst/type.Result.html' title='fst::Result'>Result</a>&lt;<a class='struct' href='../fst/struct.Regex.html' title='fst::Regex'>Regex</a>&gt;</code></h4>
<div class='docblock'><p>Create a new regular expression query.</p>

<p>The query finds all terms matching the regular expression.</p>

<p>If the regular expression is malformed or if it results in an automaton
that is too big, then an error is returned.</p>

<p>A <code>Regex</code> value satisfies the <code>Automaton</code> trait, which means it can be
used with the <code>search</code> method of any finite state transducer.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='../fst/trait.Automaton.html' title='fst::Automaton'>Automaton</a> for <a class='struct' href='../fst/struct.Regex.html' title='fst::Regex'>Regex</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-3017' class='srclink' href='../src/fst/regex/mod.rs.html#126-142' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='associatedtype.State' class='type'><code>type <a href='../fst/trait.Automaton.html#associatedtype.State' class='type'>State</a> = <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>The type of the state used in the automaton.</p>
</div><h4 id='method.start' class='method'><code>fn <a href='../fst/trait.Automaton.html#tymethod.start' class='fnname'>start</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Returns a single start state for this automaton. <a href="../fst/trait.Automaton.html#tymethod.start">Read more</a></p>
</div><h4 id='method.is_match' class='method'><code>fn <a href='../fst/trait.Automaton.html#tymethod.is_match' class='fnname'>is_match</a>(&amp;self, state: &amp;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if and only if <code>state</code> is a match state.</p>
</div><h4 id='method.can_match' class='method'><code>fn <a href='../fst/trait.Automaton.html#method.can_match' class='fnname'>can_match</a>(&amp;self, state: &amp;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if and only if <code>state</code> can lead to a match in zero or more steps. <a href="../fst/trait.Automaton.html#method.can_match">Read more</a></p>
</div><h4 id='method.accept' class='method'><code>fn <a href='../fst/trait.Automaton.html#tymethod.accept' class='fnname'>accept</a>(&amp;self, state: &amp;<a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;, byte: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Return the next state given <code>state</code> and an input.</p>
</div><h4 id='method.will_always_match' class='method'><code>fn <a href='../fst/trait.Automaton.html#method.will_always_match' class='fnname'>will_always_match</a>(&amp;self, _state: &amp;Self::State) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if and only if <code>state</code> matches and must match no matter what steps are taken. <a href="../fst/trait.Automaton.html#method.will_always_match">Read more</a></p>
</div><h4 id='method.starts_with' class='method'><code>fn <a href='../fst/trait.Automaton.html#method.starts_with' class='fnname'>starts_with</a>(self) -&gt; StartsWith&lt;Self&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a></span></code></h4>
<div class='docblock'><p>Returns an automaton that matches the strings that start with something this automaton matches. <a href="../fst/trait.Automaton.html#method.starts_with">Read more</a></p>
</div><h4 id='method.union' class='method'><code>fn <a href='../fst/trait.Automaton.html#method.union' class='fnname'>union</a>&lt;Rhs:&nbsp;<a class='trait' href='../fst/trait.Automaton.html' title='fst::Automaton'>Automaton</a>&gt;(self, rhs: Rhs) -&gt; Union&lt;Self,&nbsp;Rhs&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a></span></code></h4>
<div class='docblock'><p>Returns an automaton that matches the strings matched by either this or the other automaton. <a href="../fst/trait.Automaton.html#method.union">Read more</a></p>
</div><h4 id='method.intersection' class='method'><code>fn <a href='../fst/trait.Automaton.html#method.intersection' class='fnname'>intersection</a>&lt;Rhs:&nbsp;<a class='trait' href='../fst/trait.Automaton.html' title='fst::Automaton'>Automaton</a>&gt;(self, rhs: Rhs) -&gt; Intersection&lt;Self,&nbsp;Rhs&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a></span></code></h4>
<div class='docblock'><p>Returns an automaton that matches the strings matched by both this and the other automaton. <a href="../fst/trait.Automaton.html#method.intersection">Read more</a></p>
</div><h4 id='method.complement' class='method'><code>fn <a href='../fst/trait.Automaton.html#method.complement' class='fnname'>complement</a>(self) -&gt; Complement&lt;Self&gt; <span class='where'>where Self: <a class='trait' href='https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html' title='core::marker::Sized'>Sized</a></span></code></h4>
<div class='docblock'><p>Returns an automaton that matches the strings not matched by this automaton.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> for <a class='struct' href='../fst/struct.Regex.html' title='fst::Regex'>Regex</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-3035' class='srclink' href='../src/fst/regex/mod.rs.html#144-149' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html' title='core::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/core/fmt/type.Result.html' title='core::fmt::Result'>Result</a></code></h4>
<div class='docblock'><p>Formats the value using the given formatter.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "fst";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>